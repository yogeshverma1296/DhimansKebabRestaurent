(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module) => {
    return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
  };

  // ../client/dist/region/IsoToM49.js
  var require_IsoToM49 = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.default = {
      AD: "020",
      AE: "784",
      AF: "004",
      AG: "028",
      AI: "660",
      AL: "008",
      AM: "051",
      AO: "024",
      AQ: "010",
      AR: "032",
      AS: "016",
      AT: "040",
      AU: "036",
      AW: "533",
      AX: "248",
      AZ: "031",
      BA: "070",
      BB: "052",
      BD: "050",
      BE: "056",
      BF: "854",
      BG: "100",
      BH: "048",
      BI: "108",
      BJ: "204",
      BL: "652",
      BM: "060",
      BN: "096",
      BO: "068",
      BQ: "535",
      BR: "076",
      BS: "044",
      BT: "064",
      BV: "074",
      BW: "072",
      BY: "112",
      BZ: "084",
      CA: "124",
      CC: "166",
      CD: "180",
      CF: "140",
      CG: "178",
      CH: "756",
      CI: "384",
      CK: "184",
      CL: "152",
      CM: "120",
      CN: "156",
      CO: "170",
      CR: "188",
      CU: "192",
      CV: "132",
      CW: "531",
      CX: "162",
      CY: "196",
      CZ: "203",
      DE: "276",
      DJ: "262",
      DK: "208",
      DM: "212",
      DO: "214",
      DZ: "012",
      EC: "218",
      EE: "233",
      EG: "818",
      EH: "732",
      ER: "232",
      ES: "724",
      ET: "231",
      FI: "246",
      FJ: "242",
      FK: "238",
      FM: "583",
      FO: "234",
      FR: "250",
      GA: "266",
      GB: "826",
      GD: "308",
      GE: "268",
      GF: "254",
      GG: "831",
      GH: "288",
      GI: "292",
      GL: "304",
      GM: "270",
      GN: "324",
      GP: "312",
      GQ: "226",
      GR: "300",
      GS: "239",
      GT: "320",
      GU: "316",
      GW: "624",
      GY: "328",
      HK: "344",
      HM: "334",
      HN: "340",
      HR: "191",
      HT: "332",
      HU: "348",
      ID: "360",
      IE: "372",
      IL: "376",
      IM: "833",
      IN: "356",
      IO: "086",
      IQ: "368",
      IR: "364",
      IS: "352",
      IT: "380",
      JE: "832",
      JM: "388",
      JO: "400",
      JP: "392",
      KE: "404",
      KG: "417",
      KH: "116",
      KI: "296",
      KM: "174",
      KN: "659",
      KP: "408",
      KR: "410",
      KW: "414",
      KY: "136",
      KZ: "398",
      LA: "418",
      LB: "422",
      LC: "662",
      LI: "438",
      LK: "144",
      LR: "430",
      LS: "426",
      LT: "440",
      LU: "442",
      LV: "428",
      LY: "434",
      MA: "504",
      MC: "492",
      MD: "498",
      ME: "499",
      MF: "663",
      MG: "450",
      MH: "584",
      MK: "807",
      ML: "466",
      MM: "104",
      MN: "496",
      MO: "446",
      MP: "580",
      MQ: "474",
      MR: "478",
      MS: "500",
      MT: "470",
      MU: "480",
      MV: "462",
      MW: "454",
      MX: "484",
      MY: "458",
      MZ: "508",
      NA: "516",
      NC: "540",
      NE: "562",
      NF: "574",
      NG: "566",
      NI: "558",
      NL: "528",
      NO: "578",
      NP: "524",
      NR: "520",
      NU: "570",
      NZ: "554",
      OM: "512",
      PA: "591",
      PE: "604",
      PF: "258",
      PG: "598",
      PH: "608",
      PK: "586",
      PL: "616",
      PM: "666",
      PN: "612",
      PR: "630",
      PS: "275",
      PT: "620",
      PW: "585",
      PY: "600",
      QA: "634",
      RE: "638",
      RO: "642",
      RS: "688",
      RU: "643",
      RW: "646",
      SA: "682",
      SB: "090",
      SC: "690",
      SD: "729",
      SE: "752",
      SG: "702",
      SH: "654",
      SI: "705",
      SJ: "744",
      SK: "703",
      SL: "694",
      SM: "674",
      SN: "686",
      SO: "706",
      SR: "740",
      SS: "728",
      ST: "678",
      SV: "222",
      SX: "534",
      SY: "760",
      SZ: "748",
      TC: "796",
      TD: "148",
      TF: "260",
      TG: "768",
      TH: "764",
      TJ: "762",
      TK: "772",
      TL: "626",
      TM: "795",
      TN: "788",
      TO: "776",
      TR: "792",
      TT: "780",
      TV: "798",
      TW: "158",
      TZ: "834",
      UA: "804",
      UG: "800",
      UM: "581",
      US: "840",
      UY: "858",
      UZ: "860",
      VA: "336",
      VC: "670",
      VE: "862",
      VG: "092",
      VI: "850",
      VN: "704",
      VU: "548",
      WF: "876",
      WS: "882",
      YE: "887",
      YT: "175",
      ZA: "710",
      ZM: "894",
      ZW: "716",
      "": "001"
    };
  });

  // ../client/dist/region/getIpInfo.js
  var require_getIpInfo = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var IPINFO_PROXY_API = "https://9b81nzr2vl.execute-api.eu-west-1.amazonaws.com/production-xdai/where";
    exports.default = async () => fetch(IPINFO_PROXY_API).then((resp) => resp.json());
  });

  // ../client/dist/region/getRegionCode.js
  var require_getRegionCode = __commonJS((exports) => {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    var IsoToM49_1 = __importDefault(require_IsoToM49());
    var getIpInfo_1 = __importDefault(require_getIpInfo());
    exports.default = async () => {
      const {postal, country} = await getIpInfo_1.default().catch((e) => {
        console.error(e);
        return {country: "", postal: ""};
      });
      return {m49: IsoToM49_1.default[country], iso: country, zipCode: postal};
    };
  });

  // ../client/dist/isInExtension.js
  var require_isInExtension = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var browser = window.browser;
    var chrome2 = window.chrome;
    exports.default = () => typeof browser !== "undefined" && Object.getPrototypeOf(browser) === Object.prototype || typeof chrome2 === "object" && chrome2 && chrome2.runtime && chrome2.runtime.id;
  });

  // ../client/dist/sanitizeLang.js
  var require_sanitizeLang = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var SUPPORTED_LANGUAGES = ["en", "fr"];
    exports.default = (lang) => SUPPORTED_LANGUAGES.includes(lang) ? lang : "en";
  });

  // ../client/dist/utils.js
  var require_utils = __commonJS((exports) => {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.isMpaaExclusive = exports.getRegionByCode = exports.moviePaymentUrl = exports.tokenToImdb = exports.imdbToToken = exports.mpaaCompanies = void 0;
    var IsoToM49_1 = __importDefault(require_IsoToM49());
    var getRegionCode_1 = require_getRegionCode();
    Object.defineProperty(exports, "getRegionCode", {enumerable: true, get: function() {
      return getRegionCode_1.default;
    }});
    var isInExtension_1 = require_isInExtension();
    Object.defineProperty(exports, "isInExtension", {enumerable: true, get: function() {
      return isInExtension_1.default;
    }});
    var sanitizeLang_1 = require_sanitizeLang();
    Object.defineProperty(exports, "sanitizeLang", {enumerable: true, get: function() {
      return sanitizeLang_1.default;
    }});
    exports.mpaaCompanies = [
      "Paramount",
      "Netflix",
      "Universal Pictures",
      "Walt Disney Pictures",
      "Disney Plus",
      "Amazon Studios",
      "Warner Bros. Pictures",
      "Sony Pictures"
    ];
    var IdTypes;
    (function(IdTypes2) {
      IdTypes2[IdTypes2["NA"] = 0] = "NA";
      IdTypes2[IdTypes2["IMDB"] = 1] = "IMDB";
    })(IdTypes || (IdTypes = {}));
    exports.imdbToToken = (imdbId) => {
      return String((BigInt(imdbId.replace("tt", "")) << BigInt(8)) + BigInt(IdTypes.IMDB));
    };
    exports.tokenToImdb = (tokenId) => {
      const type = Number(BigInt(tokenId) % BigInt(256));
      if (type !== IdTypes.IMDB) {
        throw Error("Invalid type. Should be 1 for IMDB ID");
      }
      return `tt${String(BigInt(tokenId) >> BigInt(8)).padStart(7, "0")}`;
    };
    exports.moviePaymentUrl = ({movieId, region, medium, pssId, pssAddress}) => `/movie/${movieId}/${region}/${medium}/${pssId || pssAddress}`;
    exports.getRegionByCode = (regionCode) => Object.keys(IsoToM49_1.default).find((region) => IsoToM49_1.default[region] === String(regionCode)) || "";
    exports.isMpaaExclusive = (providers) => {
      const uniqueProviders = [...new Set(providers)];
      return uniqueProviders.length === 1 && exports.mpaaCompanies.includes(uniqueProviders[0]);
    };
  });

  // ../client/node_modules/lodash.merge/index.js
  var require_lodash = __commonJS((exports, module) => {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        configurable: true,
        enumerable: false,
        value: constant(string),
        writable: true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge;
  });

  // ../client/dist/protocol.js
  var require_protocol = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.isWR = exports.sendMessage = void 0;
    exports.sendMessage = (message) => {
      window.dispatchEvent(new CustomEvent("message", {detail: message}));
    };
    exports.isWR = (msg2) => msg2 && msg2.type && msg2.type.startsWith("whiterabbit.");
  });

  // ../client/dist/iframeManager/styles.js
  var require_styles = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.loaderCss = exports.closeHandleCss = exports.frameCss = void 0;
    exports.frameCss = `
  height: 600px;
  width: 390px;
  right: 0;
  position: fixed;
  background: black;
  color: white;
  border: none;
  display: none;
  z-index: 99999;
  top: 0;`;
    exports.closeHandleCss = `
  right: 0;
  top: 600px;
  position: fixed;
  background: black;
  font-size: 2rem;
  padding: 2px 5px;
  cursor: pointer;
  color: #7c7c7c;
`;
    exports.loaderCss = `
  display: flex;
  justify-content: center;
  align-items: center;`;
  });

  // ../client/dist/iframeManager/index.js
  var require_iframeManager = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    var styles_1 = require_styles();
    var IframeManager = class {
      constructor({document: providedDocument}) {
        this.iframe = null;
        this.closeHandle = null;
        this.document = providedDocument;
      }
      ensureIFrame(url, paymentRequest) {
        if (this.iframe) {
          return Promise.resolve(this.iframe);
        }
        this.paymentRequest = paymentRequest;
        return new Promise((resolve) => {
          const loader = this.document.createElement("div");
          loader.style.cssText = styles_1.frameCss + styles_1.loaderCss;
          loader.appendChild(this.document.createTextNode("Loading.."));
          this.document.body.appendChild(loader);
          this.iframe = this.document.createElement("iframe");
          this.iframe.src = url;
          this.iframe.style.cssText = styles_1.frameCss;
          this.iframe.addEventListener("load", () => {
            this.iframe.style.cssText += "display: block";
            this.document.body.removeChild(loader);
            resolve(true);
          });
          const closeHandle = this.ensureCloseHandle();
          this.document.body.appendChild(this.iframe);
          this.document.body.appendChild(closeHandle);
        });
      }
      closeIFrame() {
        if (this.iframe)
          this.document.body.removeChild(this.iframe);
        if (this.closeHandle)
          this.document.body.removeChild(this.closeHandle);
        if (this.paymentRequest) {
          const {callback, movieId} = this.paymentRequest;
          callback({
            movieId,
            status: false
          });
        }
        this.paymentRequest = void 0;
        this.iframe = null;
        this.closeHandle = null;
      }
      ensureCloseHandle() {
        if (this.closeHandle)
          return this.closeHandle;
        this.closeHandle = this.document.createElement("div");
        this.closeHandle.appendChild(this.document.createTextNode("\xD7"));
        this.closeHandle.style.cssText = styles_1.closeHandleCss;
        this.closeHandle.addEventListener("click", () => this.closeIFrame());
        return this.closeHandle;
      }
    };
    exports.default = IframeManager;
  });

  // ../client/dist/client.js
  var require_client = __commonJS((exports) => {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.WhiteRabbitClient = void 0;
    var lodash_merge_1 = __importDefault(require_lodash());
    var getRegionCode_1 = __importDefault(require_getRegionCode());
    var protocol_1 = require_protocol();
    var iframeManager_1 = __importDefault(require_iframeManager());
    var utils_1 = require_utils();
    var defaultConfig = {
      theIpInfoApiKey: "d9d5dc2c1df033",
      host: "https://wallet.whiterabbit.one",
      document
    };
    var WhiteRabbitClient = class {
      constructor(config) {
        this.config = defaultConfig;
        if (utils_1.isInExtension()) {
          this.config.extensionInstalled = true;
        }
        this.config = lodash_merge_1.default({}, this.config, config);
        this.iframeManager = new iframeManager_1.default({
          document: this.config.document || document
        });
        if (this.config.extensionInstalled === void 0) {
          window.addEventListener("message", this.handleMessage.bind(this));
          setTimeout(() => {
            protocol_1.sendMessage({
              type: "whiterabbit.msg.extension-ping"
            });
          }, 2e3);
        }
      }
      isMoviePayed(imdbOrTokenId) {
        const tokenId = imdbOrTokenId.startsWith("tt") ? utils_1.imdbToToken(imdbOrTokenId) : imdbOrTokenId;
        return new Promise((resolve) => {
          const handleCheckPaymentResponse = (event) => {
            const msg2 = event.data || event.detail;
            if (msg2.type === "whiterabbit.msg.check-movie-payment-response" && msg2.data.movieId === Number(tokenId)) {
              window.removeEventListener("message", handleCheckPaymentResponse);
              resolve(msg2.data.status);
            }
          };
          window.addEventListener("message", handleCheckPaymentResponse);
          setTimeout(() => protocol_1.sendMessage({
            type: "whiterabbit.msg.check-movie-payment-request",
            data: {
              movieId: Number(tokenId)
            }
          }), 500);
        });
      }
      handleMessage(event) {
        const rawMsg = event.data || event.detail;
        if (!protocol_1.isWR(rawMsg))
          return;
        const msg2 = rawMsg;
        if (msg2.type === "whiterabbit.msg.extension-pong") {
          this.config.extensionInstalled = true;
          window.removeEventListener("message", this.handleMessage.bind(this));
        }
      }
      handlePayment(msg2) {
        if (this.paymentRequest) {
          this.paymentRequest.callback(msg2);
        }
        this.iframeManager.closeIFrame();
      }
      url(paymentRequestData) {
        return `${this.config.host}#${utils_1.moviePaymentUrl(paymentRequestData)}`;
      }
      async requestPayment(imdbOrTokenId, partnerStreamSite, medium) {
        const tokenId = imdbOrTokenId.startsWith("tt") ? utils_1.imdbToToken(imdbOrTokenId) : imdbOrTokenId;
        const {m49: region} = await getRegionCode_1.default();
        return new Promise(async (resolve) => {
          this.paymentRequest = {
            movieId: tokenId,
            callback: resolve
          };
          const moviePaymentDetails = {
            movieId: tokenId,
            region,
            medium,
            pssAddress: partnerStreamSite
          };
          if (!this.config.extensionInstalled) {
            await this.iframeManager.ensureIFrame(this.url(moviePaymentDetails), this.paymentRequest);
            return;
          }
          const msg2 = {
            type: "whiterabbit.msg.payment-request",
            data: moviePaymentDetails
          };
          console.debug("[whiterabbit][client] Requesting payment", moviePaymentDetails);
          protocol_1.sendMessage(msg2);
        });
      }
      get extensionInstalled() {
        return !!this.config.extensionInstalled;
      }
    };
    exports.WhiteRabbitClient = WhiteRabbitClient;
  });

  // ../client/dist/medium.js
  var require_medium = __commonJS((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.toCode = exports.toMedium = exports.Medium = void 0;
    var Medium2;
    (function(Medium3) {
      Medium3["THEATER"] = "THEATER";
      Medium3["EST"] = "EST";
      Medium3["DTR"] = "DTR";
      Medium3["PAYTV"] = "PAYTV";
      Medium3["SVOD"] = "SVOD";
      Medium3["FREETV"] = "FREETV";
    })(Medium2 = exports.Medium || (exports.Medium = {}));
    var mediumCodes = {
      100: Medium2.THEATER,
      200: Medium2.EST,
      300: Medium2.DTR,
      400: Medium2.PAYTV,
      500: Medium2.SVOD,
      600: Medium2.FREETV
    };
    exports.toMedium = (code) => {
      if (typeof code === "number" || parseInt(String(code), 10)) {
        return mediumCodes[code];
      }
      return Object.values(mediumCodes).find((m) => m === code);
    };
    exports.toCode = (medium) => Object.keys(mediumCodes).find((c) => mediumCodes[Number(c)] === medium);
  });

  // ../client/dist/index.js
  var require_dist = __commonJS((exports) => {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.utils = __importStar(require_utils());
    var client_1 = require_client();
    Object.defineProperty(exports, "WhiteRabbitClient", {enumerable: true, get: function() {
      return client_1.WhiteRabbitClient;
    }});
    __exportStar2(require_medium(), exports);
    __exportStar2(require_protocol(), exports);
  });

  // extension/contentScript/index.ts
  var import_client = __toModule(require_dist());

  // extension/lib/isWR.ts
  var isWR_default = (msg2) => msg2 && msg2.type && msg2.type.startsWith("whiterabbit.");

  // extension/lib/onVideoElementFound.ts
  var onVideoElementFound_default = (document2, onVideoElementFound) => {
    const onNewVideoElement = (callback) => {
      const onNewPageElement = (mutationsList) => mutationsList.forEach((m) => m.addedNodes.forEach((node) => {
        if (node.nodeName !== "VIDEO")
          return;
        setTimeout(() => callback(node), 1e3);
      }));
      const observer = new MutationObserver(onNewPageElement);
      const pageBody = document2.getElementsByTagName("body")[0];
      const config = {attributes: false, childList: true, subtree: true};
      observer.observe(pageBody, config);
    };
    onNewVideoElement(onVideoElementFound);
    const attachToAll = (videoEls2) => [...videoEls2].forEach((video) => onVideoElementFound(video));
    const videoEls = document2.getElementsByTagName("video");
    const videoElementSearchInterval = setInterval(() => {
      if (!videoEls.item(0))
        return;
      attachToAll(videoEls);
      clearInterval(videoElementSearchInterval);
    }, 1e3);
    setTimeout(() => videoElementSearchInterval && clearInterval(videoElementSearchInterval), 7e3);
  };

  // node_modules/nanoid/index.browser.js
  if (false) {
    if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
      throw new Error("React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID.");
    }
    if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
      throw new Error("Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support");
    }
    if (typeof crypto === "undefined") {
      throw new Error("Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure.");
    }
  }
  var nanoid = (size = 21) => {
    let id = "";
    let bytes = crypto.getRandomValues(new Uint8Array(size));
    while (size--) {
      let byte = bytes[size] & 63;
      if (byte < 36) {
        id += byte.toString(36);
      } else if (byte < 62) {
        id += (byte - 26).toString(36).toUpperCase();
      } else if (byte < 63) {
        id += "_";
      } else {
        id += "-";
      }
    }
    return id;
  };

  // extension/lib/deferred.ts
  var defer = () => {
    let resolve, reject;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    return {
      promise,
      resolve,
      reject
    };
  };

  // extension/platform.ts
  var platform_default = chrome;

  // extension/contentScript/messaging/background.ts
  var BackgroundMessaging = class {
    constructor() {
      this.backgroundScriptRequests = {};
      this.senderId = `wr-content-script-${nanoid()}`;
      this.contentScriptPort = platform_default.runtime.connect(void 0, {
        name: this.senderId
      });
      this.contentScriptPort.onDisconnect.addListener(() => {
        this.contentScriptPort = void 0;
      });
      this.contentScriptPort.onMessage.addListener(this.onMessage.bind(this));
    }
    isActive() {
      return !!this.contentScriptPort;
    }
    send(msg2) {
      if (!this.isActive())
        return Promise.reject("not active");
      const deferred = defer();
      msg2.sender = `${msg2.sender || this.senderId}:${nanoid()}`;
      this.contentScriptPort.postMessage(msg2);
      this.backgroundScriptRequests[msg2.sender] = deferred;
      return deferred.promise.then((val) => {
        delete this.backgroundScriptRequests[msg2.sender];
        return val;
      });
    }
    onMessage(msg2) {
      if (!isWR_default(msg2))
        return true;
      this.sendCrossDomainPaymentMessage(msg2);
      console.debug("[whiterabbit][content script] Got message from the background script", msg2);
      const registeredRequest = this.backgroundScriptRequests[msg2.sender];
      if (registeredRequest) {
        msg2.sender = msg2.sender.split(":")[0];
        registeredRequest.resolve(msg2);
      }
      return true;
    }
    sendCrossDomainPaymentMessage(msg2) {
      if (msg2.type === "whiterabbit.msg.payment-result") {
        window.postMessage(msg2, "*");
      }
    }
  };
  var background_default = BackgroundMessaging;

  // extension/lib/encoding.ts
  var byteToHex = [];
  var hexToByte = {};
  for (let n = 0; n <= 255; ++n) {
    const hexOctet = n.toString(16).padStart(2, "0");
    byteToHex.push(hexOctet);
    hexToByte[hexOctet] = n;
  }
  var toHex = (buffer) => {
    const buff = new Uint8Array(buffer);
    const hexOctets = new Array(buff.length);
    for (let i = 0; i < buff.length; ++i)
      hexOctets[i] = byteToHex[buff[i]];
    return hexOctets.join("");
  };

  // extension/lib/vId/getFrame.ts
  var getFrame_default = (element, width, height, scaleBy, onerror) => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    let w = width;
    let h = height;
    if (width < 64 || height < 48) {
      if (onerror) {
        onerror();
      }
      return null;
    }
    if (w > scaleBy || h > scaleBy) {
      if (width > height) {
        w = scaleBy;
        h = Math.round(scaleBy * height / width);
      } else {
        h = scaleBy;
        w = Math.round(scaleBy * width / height);
      }
    }
    canvas.width = w;
    canvas.height = h;
    ctx.drawImage(element, 0, 0, w, h);
    return {imgd: ctx.getImageData(0, 0, w, h).data, w, h};
  };

  // extension/lib/vId/imageToBuffer.ts
  var imageToBuffer_default = (imgData, width, height) => {
    let w = width;
    let h = height;
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    let imgd = ctx.createImageData(w, h);
    for (let i = 0; i < imgData.length; i++) {
      imgd.data[i] = imgData[i];
    }
    ctx.putImageData(imgd, 0, 0);
    const scaleFact = 0.66;
    let nrOctaves = 0;
    let smallerSide = h > w ? w : h;
    const Min = 24;
    for (; smallerSide >= Min; nrOctaves++) {
      smallerSide *= scaleFact;
    }
    let size = 2 + w * h;
    for (let i = 1; i < nrOctaves; i++) {
      const newWidth = Math.round(w * scaleFact);
      const newHeight = Math.round(h * scaleFact);
      w = newWidth;
      h = newHeight;
      size += 2 + w * h;
    }
    w = canvas.width;
    h = canvas.height;
    let pixelSum = 0;
    let offset = 0;
    const iarr = new Int32Array(size);
    iarr[offset++] = w;
    iarr[offset++] = h;
    imgd = ctx.getImageData(0, 0, w, h).data;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const i = 4 * (w * y + x);
        const pixelValue = 0.3 * imgd[i] + 0.6 * imgd[i + 1] + 0.1 * imgd[i + 2];
        pixelSum += pixelValue;
        iarr[offset + x * h + y] = pixelValue * 256;
      }
    }
    offset += w * h;
    for (let i = 1; i < nrOctaves; i++) {
      const newWidth = Math.round(w * scaleFact);
      const newHeight = Math.round(h * scaleFact);
      ctx.drawImage(canvas, 0, 0, w, h, 0, 0, newWidth, newHeight);
      w = newWidth;
      h = newHeight;
      iarr[offset++] = w;
      iarr[offset++] = h;
      imgd = ctx.getImageData(0, 0, w, h).data;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const j = 4 * (w * y + x);
          const pixelValue = 0.3 * imgd[j] + 0.6 * imgd[j + 1] + 0.1 * imgd[j + 2];
          iarr[offset + x * h + y] = pixelValue * 256;
        }
      }
      offset += w * h;
    }
    return iarr.buffer;
  };

  // extension/lib/vId/matcher.ts
  var queryIntervalDuration = 2e3;
  var Matcher = class {
    constructor(video, messaging, startFromSecond) {
      this.matchedImdbId = "";
      this.video = video;
      this.messaging = messaging;
      this.ts = Date.now();
      this.startPosition = startFromSecond || video.currentTime;
    }
    queryMatches(imgBuff, start, end, ts) {
      const msg2 = {
        type: "whiterabbit.msg.movie-descriptor-request",
        sender: this.messaging.senderId,
        data: {
          buffer: toHex(imgBuff),
          start,
          end,
          ts
        }
      };
      return this.messaging.send(msg2);
    }
    async queryDescriptor(imgData, width, height, ts, start, end) {
      const imageBuff = imageToBuffer_default(imgData, width, height);
      const resp = await this.queryMatches(imageBuff, start, end, ts);
      if (!resp.data.matches || !resp.data.matches.length)
        return;
      console.debug("[whiterabbit] Frame matches ", resp.data.matches.map((m) => m.metadata.imdb_id).join(","));
      if (resp.data.matches.length === 1) {
        const imdbId = resp.data.matches[0].metadata.imdb_id;
        if (this.previousMatchImdbId === imdbId) {
          this.matchedImdbId = imdbId;
        }
        this.previousMatchImdbId = imdbId;
      }
    }
    getMatchingMovieId() {
      return new Promise((resolve, reject) => {
        try {
          const queryInterval = () => {
            if (this.video.paused || this.video.ended || !this.messaging.isActive)
              return;
            const queryPosition = this.video.currentTime;
            const nextQueryPosition = queryPosition + queryIntervalDuration / 1e3;
            if (this.video.currentTime < 10) {
              setTimeout(queryInterval, queryIntervalDuration);
              return;
            }
            if (this.video.ended || this.matchedImdbId || this.video.currentTime > this.startPosition + 120) {
              resolve(this.matchedImdbId);
              return;
            }
            const data = getFrame_default(this.video, this.video.videoWidth, this.video.videoHeight, 512, function() {
              setTimeout(queryInterval, queryIntervalDuration);
            });
            if (data == null) {
              return;
            }
            this.queryDescriptor(data.imgd, data.w, data.h, this.ts, queryPosition, nextQueryPosition).catch(reject);
            setTimeout(queryInterval, queryIntervalDuration);
          };
          queryInterval();
        } catch (e) {
          reject(e);
        }
      });
    }
  };
  var matcher_default = Matcher;

  // node_modules/@cliqz/adblocker-extended-selectors/dist/es6/src/types.js
  /*!
   * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   */

  // node_modules/@cliqz/adblocker-extended-selectors/dist/es6/src/parse.js
  /*!
   * Based on parsel. Extended by Rémi Berson for Ghostery (2021).
   * https://github.com/LeaVerou/parsel
   *
   * MIT License
   *
   * Copyright (c) 2020 Lea Verou
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var RECURSIVE_PSEUDO_CLASSES = new Set([
    "any",
    "dir",
    "has",
    "host-context",
    "if",
    "if-not",
    "is",
    "matches",
    "not",
    "where"
  ]);
  var TOKENS = {
    attribute: /\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(?<caseSensitive>[iIsS])?\s*)?\]/gu,
    id: /#(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu,
    class: /\.(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu,
    comma: /\s*,\s*/g,
    combinator: /\s*[\s>+~]\s*/g,
    "pseudo-element": /::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?:¶*)\))?/gu,
    "pseudo-class": /:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶*)\))?/gu,
    type: /(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu
  };
  var TOKENS_WITH_PARENS = new Set(["pseudo-class", "pseudo-element"]);
  var TOKENS_WITH_STRINGS = new Set([...TOKENS_WITH_PARENS, "attribute"]);
  var TRIM_TOKENS = new Set(["combinator", "comma"]);
  var TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);
  TOKENS_FOR_RESTORE["pseudo-element"] = RegExp(TOKENS["pseudo-element"].source.replace("(?<argument>\xB6*)", "(?<argument>.*?)"), "gu");
  TOKENS_FOR_RESTORE["pseudo-class"] = RegExp(TOKENS["pseudo-class"].source.replace("(?<argument>\xB6*)", "(?<argument>.*)"), "gu");

  // node_modules/@cliqz/adblocker-extended-selectors/dist/es6/src/eval.js
  /*!
   * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   */
  function matchPattern(pattern, text) {
    if (pattern.startsWith("/") && (pattern.endsWith("/") || pattern.endsWith("/i"))) {
      let caseSensitive = true;
      pattern = pattern.slice(1);
      if (pattern.endsWith("/")) {
        pattern = pattern.slice(0, -1);
      } else {
        pattern = pattern.slice(0, -2);
        caseSensitive = false;
      }
      return new RegExp(pattern, caseSensitive === false ? "i" : void 0).test(text);
    }
    return text.includes(pattern);
  }
  function matches(element, selector) {
    if (selector.type === "id" || selector.type === "class" || selector.type === "type" || selector.type === "attribute") {
      return element.matches(selector.content);
    } else if (selector.type === "list") {
      return selector.list.some((s) => matches(element, s));
    } else if (selector.type === "compound") {
      return selector.compound.every((s) => matches(element, s));
    } else if (selector.type === "pseudo-class") {
      if (selector.name === "has" || selector.name === "if") {
        return selector.subtree !== void 0 && querySelectorAll(element, selector.subtree).length !== 0;
      } else if (selector.name === "not") {
        return selector.subtree !== void 0 && matches(element, selector.subtree) === false;
      } else if (selector.name === "has-text") {
        const {argument} = selector;
        if (argument === void 0) {
          return false;
        }
        const text = element.textContent;
        if (text === null) {
          return false;
        }
        return matchPattern(argument, text);
      } else if (selector.name === "min-text-length") {
        const minLength = Number(selector.argument);
        if (Number.isNaN(minLength) || minLength < 0) {
          return false;
        }
        const text = element.textContent;
        if (text === null) {
          return false;
        }
        return text.length >= minLength;
      }
    }
    return false;
  }
  function querySelectorAll(element, selector) {
    const elements = [];
    if (selector.type === "id" || selector.type === "class" || selector.type === "type" || selector.type === "attribute") {
      elements.push(...element.querySelectorAll(selector.content));
    } else if (selector.type === "list") {
      for (const subSelector of selector.list) {
        elements.push(...querySelectorAll(element, subSelector));
      }
    } else if (selector.type === "compound") {
      if (selector.compound.length !== 0) {
        elements.push(...querySelectorAll(element, selector.compound[0]).filter((e) => selector.compound.slice(1).every((s) => matches(e, s))));
      }
    } else if (selector.type === "complex") {
      const elements2 = selector.left === void 0 ? [element] : querySelectorAll(element, selector.left);
      if (selector.combinator === " ") {
        for (const element2 of elements2) {
          elements.push(...querySelectorAll(element2, selector.right));
        }
      } else if (selector.combinator === ">") {
        for (const element2 of elements2) {
          for (const child of element2.children) {
            if (matches(child, selector.right) === true) {
              elements.push(child);
            }
          }
        }
      } else if (selector.combinator === "~") {
        for (const element2 of elements2) {
          let sibling = element2;
          while ((sibling = sibling.nextElementSibling) !== null) {
            if (matches(sibling, selector.right) === true) {
              elements.push(sibling);
            }
          }
        }
      } else if (selector.combinator === "+") {
        for (const element2 of elements2) {
          const nextElementSibling = element2.nextElementSibling;
          if (nextElementSibling !== null && matches(nextElementSibling, selector.right) === true) {
            elements.push(nextElementSibling);
          }
        }
      }
    } else if (selector.type === "pseudo-class") {
      for (const subElement of element.querySelectorAll("*")) {
        if (matches(subElement, selector) === true) {
          elements.push(subElement);
        }
      }
    }
    return elements;
  }

  // node_modules/@cliqz/adblocker-extended-selectors/dist/es6/src/extended.js
  /*!
   * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   */
  var EXTENDED_PSEUDO_CLASSES = new Set([
    "has",
    "has-text",
    "if"
  ]);
  var PSEUDO_CLASSES = new Set([
    "active",
    "any",
    "any-link",
    "blank",
    "checked",
    "default",
    "defined",
    "dir",
    "disabled",
    "empty",
    "enabled",
    "first",
    "first-child",
    "first-of-type",
    "focus",
    "focus-visible",
    "focus-within",
    "fullscreen",
    "host",
    "host-context",
    "hover",
    "in-range",
    "indeterminate",
    "invalid",
    "is",
    "lang",
    "last-child",
    "last-of-type",
    "left",
    "link",
    "matches",
    "not",
    "nth-child",
    "nth-last-child",
    "nth-last-of-type",
    "nth-of-type",
    "only-child",
    "only-of-type",
    "optional",
    "out-of-range",
    "placeholder-shown",
    "read-only",
    "read-write",
    "required",
    "right",
    "root",
    "scope",
    "target",
    "valid",
    "visited",
    "where"
  ]);
  var PSEUDO_ELEMENTS = new Set(["after", "before", "first-letter", "first-line"]);
  var SelectorType;
  (function(SelectorType2) {
    SelectorType2[SelectorType2["Normal"] = 0] = "Normal";
    SelectorType2[SelectorType2["Extended"] = 1] = "Extended";
    SelectorType2[SelectorType2["Invalid"] = 2] = "Invalid";
  })(SelectorType || (SelectorType = {}));

  // node_modules/@cliqz/adblocker-extended-selectors/dist/es6/adblocker.js
  /*!
   * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   */

  // node_modules/@cliqz/adblocker-content/dist/es6/adblocker.js
  /*!
   * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   */
  var SCRIPT_ID = "cliqz-adblocker-script";
  var IGNORED_TAGS = new Set(["br", "head", "link", "meta", "script", "style", "s"]);
  function isElement(node) {
    return node.nodeType === 1;
  }
  function getElementsFromMutations(mutations) {
    const elements = [];
    for (const mutation of mutations) {
      if (mutation.type === "attributes") {
        if (isElement(mutation.target)) {
          elements.push(mutation.target);
        }
      } else if (mutation.type === "childList") {
        for (const addedNode of mutation.addedNodes) {
          if (isElement(addedNode) && addedNode.id !== SCRIPT_ID) {
            elements.push(addedNode);
          }
        }
      }
    }
    return elements;
  }
  function extractFeaturesFromDOM(roots) {
    const ignoredTags = new Set(["br", "head", "link", "meta", "script", "style", "s"]);
    const classes = new Set();
    const hrefs = new Set();
    const ids = new Set();
    for (const root of roots) {
      for (const element of [root, ...root.querySelectorAll("[id],[class],[href]")]) {
        if (ignoredTags.has(element.nodeName.toLowerCase())) {
          continue;
        }
        const id = element.id;
        if (id) {
          ids.add(id);
        }
        const classList = element.classList;
        if (classList) {
          for (const cls of classList) {
            classes.add(cls);
          }
        }
        const href = element.getAttribute("href");
        if (typeof href === "string") {
          hrefs.add(href);
        }
      }
    }
    return {
      classes: Array.from(classes),
      hrefs: Array.from(hrefs),
      ids: Array.from(ids)
    };
  }
  var DOMMonitor = class {
    constructor(cb) {
      this.cb = cb;
      this.knownIds = new Set();
      this.knownHrefs = new Set();
      this.knownClasses = new Set();
      this.observer = null;
    }
    queryAll(window2) {
      this.cb({type: "elements", elements: [window2.document.documentElement]});
      this.handleUpdatedNodes([window2.document.documentElement]);
    }
    start(window2) {
      if (this.observer === null && window2.MutationObserver !== void 0) {
        this.observer = new window2.MutationObserver((mutations) => {
          this.handleUpdatedNodes(getElementsFromMutations(mutations));
        });
        this.observer.observe(window2.document.documentElement, {
          attributes: true,
          attributeFilter: ["class", "id", "href"],
          childList: true,
          subtree: true
        });
      }
    }
    stop() {
      if (this.observer !== null) {
        this.observer.disconnect();
        this.observer = null;
      }
    }
    handleNewFeatures({hrefs, ids, classes}) {
      const newIds = [];
      const newClasses = [];
      const newHrefs = [];
      for (const id of ids) {
        if (this.knownIds.has(id) === false) {
          newIds.push(id);
          this.knownIds.add(id);
        }
      }
      for (const cls of classes) {
        if (this.knownClasses.has(cls) === false) {
          newClasses.push(cls);
          this.knownClasses.add(cls);
        }
      }
      for (const href of hrefs) {
        if (this.knownHrefs.has(href) === false) {
          newHrefs.push(href);
          this.knownHrefs.add(href);
        }
      }
      if (newIds.length !== 0 || newClasses.length !== 0 || newHrefs.length !== 0) {
        this.cb({
          type: "features",
          classes: newClasses,
          hrefs: newHrefs,
          ids: newIds
        });
        return true;
      }
      return false;
    }
    handleUpdatedNodes(elements) {
      if (elements.length !== 0) {
        this.cb({
          type: "elements",
          elements: elements.filter((e) => IGNORED_TAGS.has(e.nodeName.toLowerCase()) === false)
        });
        return this.handleNewFeatures(extractFeaturesFromDOM(elements));
      }
      return false;
    }
  };
  function autoRemoveScript(script) {
    return `try{${script}}catch(c){}!function(){var c=document.currentScript,e=c&&c.parentNode;e&&e.removeChild(c)}();`;
  }
  function injectScript(s, doc) {
    const script = doc.createElement("script");
    script.type = "text/javascript";
    script.id = SCRIPT_ID;
    script.async = false;
    script.appendChild(doc.createTextNode(autoRemoveScript(s)));
    const parent = doc.head || doc.documentElement;
    if (parent !== null) {
      parent.appendChild(script);
    }
  }

  // node_modules/@cliqz/adblocker-webextension-cosmetics/dist/es6/adblocker.js
  /*!
   * Copyright (c) 2017-present Cliqz GmbH. All rights reserved.
   *
   * This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at https://mozilla.org/MPL/2.0/.
   */
  var ACTIVE = true;
  var DOM_MONITOR = null;
  var UPDATE_EXTENDED_TIMEOUT = null;
  var PENDING = new Set();
  var EXTENDED = [];
  var HIDDEN = new Map();
  function unload() {
    if (DOM_MONITOR !== null) {
      DOM_MONITOR.stop();
      DOM_MONITOR = null;
    }
  }
  function getCosmeticsFiltersWithSendMessage(arg) {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage(Object.assign({action: "getCosmeticsFilters"}, arg), (response) => {
        if (response !== void 0) {
          resolve(response);
        }
      });
    });
  }
  function cachedQuerySelector(root, selector, cache) {
    var _a;
    const cachedElements = (_a = cache.get(root)) === null || _a === void 0 ? void 0 : _a.get(selector);
    if (cachedElements !== void 0) {
      return cachedElements;
    }
    const selected = new Set(querySelectorAll(root, selector.ast));
    if (selector.attribute !== void 0) {
      let cachedSelectors = cache.get(root);
      if (cachedSelectors === void 0) {
        cachedSelectors = new Map();
        cache.set(root, cachedSelectors);
      }
      let cachedSelected = cachedSelectors.get(selector);
      if (cachedSelected === void 0) {
        cachedSelected = new Set();
        cachedSelectors.set(selector, cachedSelected);
      }
      for (const element of selected) {
        cachedSelected.add(element);
      }
    }
    return selected;
  }
  function updateExtended() {
    if (PENDING.size === 0 || EXTENDED.length === 0) {
      return;
    }
    const cache = new Map();
    const elementsToHide = new Map();
    const roots = [...PENDING].filter((e) => e.isConnected === true);
    PENDING.clear();
    for (const root of roots) {
      for (const selector of EXTENDED) {
        for (const element of cachedQuerySelector(root, selector, cache)) {
          if (selector.remove === true) {
            element.textContent = "";
            element.remove();
          } else if (selector.attribute !== void 0 && HIDDEN.has(element) === false) {
            elementsToHide.set(element, {selector, root});
          }
        }
      }
    }
    for (const [element, {selector, root}] of elementsToHide.entries()) {
      if (selector.attribute !== void 0) {
        element.setAttribute(selector.attribute, "");
        HIDDEN.set(element, {selector, root});
      }
    }
    for (const [element, {selector, root}] of [...HIDDEN.entries()]) {
      if (selector.attribute !== void 0) {
        if (root.isConnected === false || element.isConnected === false || cachedQuerySelector(root, selector, cache).has(element) === false) {
          HIDDEN.delete(element);
          element.removeAttribute(selector.attribute);
        }
      }
    }
  }
  function delayedUpdateExtended(elements) {
    if (EXTENDED.length === 0) {
      return;
    }
    if (PENDING.has(window.document.documentElement)) {
      return;
    }
    for (const element of elements) {
      if (element === window.document.documentElement) {
        PENDING.clear();
        PENDING.add(element);
        break;
      }
      PENDING.add(element);
    }
    if (UPDATE_EXTENDED_TIMEOUT === null) {
      UPDATE_EXTENDED_TIMEOUT = setTimeout(() => {
        UPDATE_EXTENDED_TIMEOUT = null;
        updateExtended();
      }, 1e3);
    }
  }
  function handleResponseFromBackground(window2, {active, scripts, extended}) {
    if (active === false) {
      ACTIVE = false;
      unload();
      return;
    } else {
      ACTIVE = true;
    }
    if (scripts) {
      setTimeout(() => {
        for (const script of scripts) {
          injectScript(script, window2.document);
        }
      }, 0);
    }
    if (extended && extended.length > 0) {
      EXTENDED.push(...extended);
      delayedUpdateExtended([window2.document.documentElement]);
    }
  }
  function injectCosmetics(window2, enableMutationObserver = true, getCosmeticsFilters = getCosmeticsFiltersWithSendMessage) {
    getCosmeticsFilters({lifecycle: "start", ids: [], classes: [], hrefs: []}).then((response) => handleResponseFromBackground(window2, response));
    window2.addEventListener("DOMContentLoaded", () => {
      DOM_MONITOR = new DOMMonitor((update) => {
        if (update.type === "elements") {
          if (update.elements.length !== 0) {
            delayedUpdateExtended(update.elements);
          }
        } else {
          getCosmeticsFilters(Object.assign(Object.assign({}, update), {lifecycle: "dom-update"})).then((response) => handleResponseFromBackground(window2, response));
        }
      });
      DOM_MONITOR.queryAll(window2);
      if (ACTIVE && enableMutationObserver) {
        DOM_MONITOR.start(window2);
      }
    }, {once: true, passive: true});
    window2.addEventListener("", unload, {once: true, passive: true});
  }

  // extension/contentScript/index.ts
  var videos = {};
  var DEFAULT_PSS_ADDR = "0x17eEF75604716f8D45D4d3a2D32FdC9C7Ea5De05";
  var backgroundScript = new background_default();
  var requestPayment = async (imdbOrTokenId, partnerStreamSite, medium, video) => {
    const tokenId = imdbOrTokenId.startsWith("tt") ? import_client.utils.imdbToToken(imdbOrTokenId) : imdbOrTokenId;
    const {status: isPaidAlready} = await backgroundScript.send({
      type: "whiterabbit.msg.check-movie-payment",
      data: {
        movieId: tokenId
      }
    });
    if (isPaidAlready) {
      console.debug("[whiterabbit][client] user already paid for the movie. Skipping payment");
      return;
    }
    if (video) {
      video.pause();
    }
    const {m49: region} = await import_client.utils.getRegionCode();
    const moviePaymentDetails = {
      movieId: tokenId,
      region,
      medium,
      pssAddress: partnerStreamSite
    };
    const msg2 = {
      type: "whiterabbit.msg.payment-request",
      data: moviePaymentDetails
    };
    console.debug("[whiterabbit][client] Requesting payment", moviePaymentDetails);
    return backgroundScript.send(msg2);
  };
  window.addEventListener("message", async (event) => {
    const rawMsg = event.data || event.detail;
    if (!isWR_default(rawMsg))
      return true;
    const msg2 = rawMsg;
    if (msg2.sender && msg2.sender !== backgroundScript.senderId)
      return true;
    console.debug("[whiterabbit][content script] Got message from the page", msg2);
    if (msg2.type === "whiterabbit.msg.extension-ping") {
      window.postMessage({type: "whiterabbit.msg.extension-pong"}, "*");
      return true;
    } else if (msg2.type === "whiterabbit.msg.movie-frames-response") {
      if (msg2.data.success) {
        console.debug("[whiterabbit][content script] processing request", msg2);
        requestPayment(msg2.data.imdbId, DEFAULT_PSS_ADDR, import_client.Medium.EST);
      }
      return true;
    } else if (msg2.type === "whiterabbit.msg.check-movie-payment-request") {
      const {movieId} = msg2.data;
      const {status} = await backgroundScript.send({
        type: "whiterabbit.msg.check-movie-payment",
        data: {
          movieId
        }
      });
      window.postMessage({
        type: "whiterabbit.msg.check-movie-payment-response",
        data: {
          movieId,
          status
        }
      }, "*");
      return true;
    }
    backgroundScript.send(msg2);
  }, false);
  var attachMovieDetection = (video) => {
    if (videos[video.src])
      return;
    videos[video.src] = true;
    console.debug("[whiterabbit] Found video element", video, video.src);
    let matchingMovieId;
    let paymentRequested;
    let inProgress;
    const onPlay = () => {
      setTimeout(async () => {
        if (!matchingMovieId && paymentRequested)
          return;
        paymentRequested = true;
        await requestPayment(matchingMovieId, DEFAULT_PSS_ADDR, import_client.Medium.EST, video);
        await video.play();
      }, 5e3);
    };
    const setBadge = (badge) => {
      backgroundScript.send({
        type: "whiterabbit.msg.set-badge",
        badge
      });
    };
    const onPlaying = async () => {
      if (matchingMovieId || inProgress)
        return;
      console.debug("[whiterabbit] Starting movie identification");
      inProgress = true;
      try {
        if (video.src && !video.src.startsWith("blob:")) {
          console.debug("[whiterabbit] Identifying the movie in the background script..");
          const msg2 = {
            type: "whiterabbit.msg.process-video",
            src: video.src
          };
          const {imdbId, error} = await backgroundScript.send(msg2);
          if (error) {
            inProgress = false;
            setBadge("failure");
            console.error(error);
            return;
          }
          if (imdbId) {
            console.log("[whiterabbit] Got matching movie", imdbId);
          } else {
            console.log("[whiterabbit] No matching movie");
          }
          matchingMovieId = imdbId || "";
          inProgress = false;
        } else {
          console.debug("[whiterabbit] Identifying the movie..");
          setBadge("progress");
          const imdbId = await new matcher_default(video, backgroundScript).getMatchingMovieId();
          if (imdbId) {
            setBadge("success");
            console.log("[whiterabbit] Got matching movie", imdbId);
          } else {
            setBadge("no-match");
            console.log("[whiterabbit] No matching movie");
          }
          matchingMovieId = imdbId || "";
          inProgress = false;
        }
        onPlay();
      } catch (e) {
        inProgress = false;
        setBadge("failure");
        console.error(e);
        throw e;
      }
    };
    video.addEventListener("play", onPlay);
    if (video.autoplay) {
      onPlaying();
    } else {
      video.addEventListener("playing", onPlaying);
    }
  };
  var host = new URL(document.location.toString()).host.replace(/^www\./, "");
  var origins = [...document.location.ancestorOrigins].map((a) => new URL(a).host.replace(/^www\./, ""));
  var hosts = [host, ...origins];
  var msg = {
    type: "whiterabbit.msg.get-config"
  };
  backgroundScript.send(msg).then((resp) => {
    const config = resp.data;
    if (!config.recognition.enabled)
      return;
    const isAllowed = config.recognition.allowedWebsites.length === 0 || !!hosts.find((h) => config.recognition.allowedWebsites.includes(h));
    if (!isAllowed)
      return;
    const isDisallowed = !!hosts.find((h) => config.recognition.disallowedWebsites.includes(h));
    if (!isDisallowed) {
      onVideoElementFound_default(document, attachMovieDetection.bind(void 0));
    }
  }).catch((e) => {
    console.error(e);
    onVideoElementFound_default(document, attachMovieDetection.bind(void 0));
  });
  injectCosmetics(window, true);
})();
